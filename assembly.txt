LAB6- condicionais
      0 => B"0100_011_000000000", --LD R3, 0
      1 => B"0100_100_000000000", --LD R4, 0
      2 => B"0001_011_000000000", --MOV A,R3
      3 => B"0111_100_000000000", --ADD A,R4
      4 => B"0010_100_000000000", --MOV R4,A
      5 => B"0011_000_000000001", --LD A,1
      6 => B"0111_011_000000000", --ADD A,R3
      7 => B"0010_011_000000000", --MOV R3,A
      8 => B"0011_000_000011110", --LD A,30
      9 => B"1010_011_000000000", --CMP R3,A
      10 => B"0110_001_011111000", --JPB 1, -8
      11 => B"0001_100_000000000", --MOV A,R4
      12 => B"0010_101_000000000", --MOV R5,A
      13 => B"0000_000_000000000", --NOP

LAB7 -Ram

      LD R1, 0x3F;
      LD R2, 0x16;
      LD R3, 0x27;
      LD R4, 0x07;
      LD R5, 0x3D;
      LD R6, 0x02;
      NOP;
      LD R7, 0X01;
      NOP;
      SW R2, (R1);
      SW R3, (R4);
      LD R4, 0x0C;
      SW R1, (R4);
      LD R4, 0x02;
      SW R6, (R4);
      LD R4, 0x03;
      SW R7, (R4);
      NOP;
      LD R1, 0;
      NOP;
      SW R4, (R4);
      LD R6, 0x0A;
      LW R2, (R6);
      LD R3, 0xFFE;
      SW R4, (R6)

Crivo de Erastotenes

 --Carrega os numeros na RAM em sequencia
      0 => B"0100_001_000000000", -- LD R1,0;
      1 => B"0011_000_000000001", -- LD A,1;
      2 => B"0111_001_000000000", -- ADD A, R1;
      3 => B"0010_001_000000000", -- MOV R1, A;
      4 => B"1100_001_001_000000", -- SW R1, (R1);
      5 => B"0011_000_000100000", -- LD A, 32; 
      6 => B"1010_001_000000000", -- CMP R1, A;
      7 => B"0110_001_011111010", -- JPB 1, -6;
      
      --Escolhe o primeiro numero e verifica se é primo
      8 => B"0100_100_000000010", -- LD R4, 2;
      9 => B"1011_101_100_000000", -- LW R5, (R4)
      10 => B"0011_000_000000000",-- LD A, 0;
      11 => B"1010_101_000000000", -- CMP R5, A;
      12 => B"0110_000_000001010", -- JPB 0, 10; --Se nao for primo pula para o proximo numero
      13 => B"0001_101_000000000", -- MOV A, R5
      14 => B"0010_001_000000000", -- MOV R1, A
      
      --Se for primo elimina os multiplos
      15 => B"0001_101_000000000", -- MOV A, R5
      16 => B"0111_001_000000000", -- ADD A, R1;
      17 => B"0010_001_000000000", -- MOV R1, A;
      18 => B"1100_000_001_000000", -- SW R0, (R1);
      19 => B"0011_000_000100000", -- LD A, 32; 
      20 => B"1010_001_000000000", -- CMP R1, A;
      21 => B"0110_001_011111010", -- JPB 1, -6;
      
      --Vai ao proximo numero
      22 => B"0011_000_000000001", -- LD A, 1;
      23 => B"0111_100_000000000",-- ADD A, R4;
      24 => B"0010_100_000000000",-- MOV R4, A
      
      --Verifica se é menor que o limite 32 e volta ao inicio
      25 => B"0011_000_000100000",-- LD A, 32
      26 => B"1010_100_000000000", -- CMP R4, A
      27 => B"0110_001_011101110", -- JPB 1, -18

      --Itera a ram e coloca o resultado na saida da ula
      28=>B"0100_001_000000001", --LD R1, 1;
      29=>B"0011_000_000000001", --LD A, 1;
      30=>B"0111_001_000000000", --ADD A, R1;
      31=>B"0010_001_000000000", --MOV R1,A;
      32=>B"1011_011_001_000000", --LW R3, (R1);
      33=>B"0011_000_000100000", --LD A, 32;
      34=>B"1010_001_000000000", --CMP R1, A;
      35=>B"0110_001_011111010", --JPB 1, -6;
      

