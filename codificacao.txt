    MSB b15               b0 LSB
        |                 |
NOP:    0000 aaaa bbbb xxxx 

ADD:    0001 aaaa bbbb xxxx

SUB:    0010 aaaa bbbb xxxx

MOV:    0011 aaaa bbbb xxxx

LD:     0100 aaaa cccccccc

JMP:    0101 iiiiiii xxxxx

CMP:    0110 xxxx aaaa xxxx

BLT:    0111 tttt aaaa dddd

BEQ:    1000 tttt aaaa dddd 

SUBI:   1001 aaaa cccccccc 

SUBB:   

Onde:
     aaaa           identifica o registrador de destino e o primeiro operando.
     bbbb           identifica o segundo operando.
     cccccccc       identifica o imediato de 8 bits em complemento de 2.
     iiiiiii        identifica o endereco absoluto de destino (7 bits).
     tttt           identfica os 4 bits MSB do endereço relativo da branch, em complemento de 2 (8 bits). (Isso ta bizarro juro que vamos mudar para a proxima entrega)
     dddd           identfica os 4 bits LSB do endereço relativo da branch, em complemento de 2 (8 bits). (Endereço relativo = ttttdddd)
     xxxx           irrelevante.

Endereçamento de Registradores:

    Utilizamos 3 bits para identificar um registrador (oito registradores), porém, de acordo com as especificações sorteadas para nosso microprocessador,
    todas as operações devem ser entre dois operandos, onde um deles é o acumulador. Dessa forma, para codificar operações análogas,
    como "MOV A, Rn" e "MOV Rn, A", em que o registrador onde é escrito pode ser tanto do Banco de Registrador como o Acumulador,
    vamos usar 4 bits para identficá-los. Assim, temos:

        MSB b3  b0 LSB
            |   |
            a xxx

    Onde: 
    a       identifica se o endereço em questão é referente ao acumulador.
    x       identifica o endereço do registrador no banco. Caso "a" seja 1, o valor de "xxx" é irrelevante, pois se trata do acumulador.

    (desnecessário acho que para a proxima entrega vamos fazer opcodes diferentes para operações análogas, 15 opcodes são suficiente)
    